DEFAULT_NODE = 'docker-fluffgst-ubuntu-bionic'
DEFAULT_TEST_NODE = "linux-amd-gpu"
FLUSTER_REPO = 'git@github.com:fluendo/fluster.git'
FLUSTER_RESULT_REPO = 'git@bitbucket.org:fluendo/fluster-results.git'
DEFAULT_LIBVA_BRANCH = '2.10.0'

IS_RELEASE = false
RELEASE_TAG_PREFIX = 'FLU-VA-DRIVERS'
RELEASE_VERSION_PATTERN = /\d+\.\d+\.\d+/
RELEASE_TAG_PATTERN = /${RELEASE_TAG_PREFIX}-([A-Z]+)-(${RELEASE_VERSION_PATTERN})/
RELEASE_TARGET_DISTROS = [
    [distro: 'generic', extension: 'tar.bz2'],
    [distro: 'debian', extension: 'deb'],
]

DRIVERS = [
  'vdpau',
]

FLUSTER_CONFIG = [
    'vdpau': [
        decoder: 'Fluendo-H.264-HW-Gst1.0',
        ts: 'JVT-AVC_V1',
        th: 54,
        tth: 2 * 60
    ],
]

DEFAULT_CREDENTIALS = [[
    $class: 'UsernamePasswordMultiBinding',
    credentialsId: 'backoffice',
    usernameVariable: 'USERNAME',
    passwordVariable: 'PASSWORD'
]]

properties([
    parameters([
        extendedChoice(
            name: 'DRIVERS',
            value: DRIVERS.join(','),
            defaultValue: 'vdpau',
            description: 'The driver to build.',
            type: 'PT_MULTI_SELECT',
            visibleItemCount: DRIVERS.size(),
        ),
        string(
            name: 'BRANCH',
            defaultValue: '',
            description: 'Branch to build the codec (to relase use VERSION)',
        ),
        string(
            name: 'FLUSTER_RESULTS_BRANCH',
            defaultValue: 'master',
            description: 'Branch to use to compare the fluster execution',
        ),
    ]),
])

node(DEFAULT_NODE) {
    def cbc="flu-va-drivers-${env.BRANCH_NAME}.cbc"

    stage('Setup') {
        IS_RELEASE = isRelease(env.TAG_NAME)
        RELEASE_VERSION = '666.666.666'
        DRIVERS = params.DRIVERS.split(',')
        if (IS_RELEASE) {
            def pattern = /${RELEASE_TAG_PREFIX}-([A-Z]+)-(${RELEASE_VERSION_PATTERN})/
            def matcher = env.TAG_NAME =~ pattern

            if (matcher.size() != 1 && matcher[0].size() != 3) {
                error('Bad tag format')
            }
            def driver = matcher[0][1].toLowerCase()
            if (!DRIVERS.contains(driver)) {
                error("Driver '${driver}' is not supported")
            }
            DRIVERS = [driver]
            RELEASE_VERSION = matcher[0][2]
        }

        // checkout scm
        sh 'git clone git@bitbucket.org:fluendo/flu-va-drivers.git'
        checkoutCerbero()

        dir('fluendo-cerbero') {
            def _cbc = 'projects/flu-va-drivers/flu-va-drivers.cbc'
            def recipes = DRIVERS.collect { "flu-va-drivers-${it}" }.join(' ')
            sh (script: "./cerbero-uninstalled -t -c ${_cbc} gen-manifest-cbc ${recipes} ${env.BRANCH_NAME} ${_cbc} ${cbc}",
                label: 'cerbero gen-manifest-cbc')
            sh (script: "./cerbero-uninstalled -t -c ${cbc} bootstrap --fridge -y",
                label: 'cerbero bootstrap')
        }
    }

    for (driver in DRIVERS) {
        stage(driver) {
            // Empty: Just to draw a beatiful node in BlueOcean.
        }

        def outputDirInWS = "packages/${driver}"
        def outputDir = "${env.WORKSPACE}/${outputDirInWS}"

        dir('fluendo-cerbero') {
            def recipe = "flu-va-drivers-${driver}"
            stage('Build') {
                sh (script: "./cerbero-uninstalled -t -c ${cbc} build --fridge ${recipe}",
                    label: 'cerbero build')
            }

            stage('Package') {
                def pkg = "flu-va-drivers-${driver}"


                for (targetDistro in RELEASE_TARGET_DISTROS) {
                    def args = [
                        recipe,
                        '-o', "${outputDir}/${targetDistro.distro}",
                    ]
                    if (targetDistro.distro == 'generic') {
                        args += ['--tarball']
                    }
                    args = args.join(' ')

                    sh "mkdir -p ${outputDir}/${targetDistro.distro}"
                    sh (script: "./cerbero-uninstalled -t -c ${cbc} package ${args}",
                        label: "Package for '${targetDistro.distro}'.")
                }
            }
        }

        stage('Upload packages') {
            def globPattern = "${outputDirInWS}/**"
            stash(name: driver, includes: globPattern)
            archiveArtifacts(artifacts: globPattern, allowEmptyArchive: true, fingerprint: true)
        }

        node(DEFAULT_TEST_NODE) {
            def driverName = "flu_va_drivers_${driver}"
            def logDirInWS = "fluster/logs/${driverName}"
            def logDir = "${env.WORKSPACE}/${logDirInWS}"
            def libvaPrefix = "${env.WORKSPACE}/libva_prefix"

            stage('Test') {
                // Setup libva
                dir('libva') {
                    deleteDir()
                    sh(script: "git clone https://github.com/intel/libva -b ${DEFAULT_LIBVA_BRANCH} .",
                        label: 'Clone libva')
                    sh("mkdir -p ${libvaPrefix} && meson --prefix=${libvaPrefix} builddir")
                    sh(script: 'ninja -C builddir install', label: 'Build libva')
                }

                // Setup Fluster
                def fluster = FLUSTER_CONFIG[driver];
                fluster.resourcesDir = './resources'
                fluster.repoDir = './fluster'
                fluster.mainArgs = '--no-emoji -r ./fluster'

                flusterCloneRepo(fluster.repoDir)
                flusterDownloadTS(fluster)

                unstash(driver)
                sh(script: "sudo apt install --reinstall --allow-downgrades -y ${env.WORKSPACE}/${outputDirInWS}/debian/*.deb",
                   label:"Install ${}")

                def gstPluginPath = "${env.WORKSPACE}/plugins"
                sh(script: "mkdir -p ${gstPluginPath}", label: 'Setup Fluster: Create GST_PLUGIN_PATH for Fluster')

                checkoutCerbero()
                dir('fluendo-cerbero') {
                    withCredentials(DEFAULT_CREDENTIALS) {
                        sh(script: (
                            './cerbero-uninstalled -c projects/codecs/1.0/native.cbc fetch-codecs ' +
                            '-t custom -s linux -g 1.0 -a x86_64 flu-plugins-gst-fluendo-vadec-h264-1.0 ' +
                            '--username \$USERNAME --password \$PASSWORD ' +
                            "-o ${gstPluginPath}"),
                           label: 'Setup Fluster: Fetch fluvadec to GST_PLUGIN_PATH')
                    }
                }

                sh(script: "ls -al ${gstPluginPath}", label: 'ls gstPluginPath')

                dir(fluster.repoDir) {
                    def vaapiLogDir = "${logDir}/vaapi"

                    sh(script: "mkdir -p ${logDir} ${vaapiLogDir}", label: 'Create log directory.')
                    withEnv([
                        'DISPLAY=:0',
                        "LD_LIBRARY_PATH=${libvaPrefix}/lib/x86_64-linux-gnu",
                        "LIBVA_TRACE=${vaapiLogDir}/vaapi_log",
                        'LIBVA_DRIVERS_PATH=/usr/lib/x86_64-linux-gnu/dri/',
                        "LIBVA_DRIVER_NAME=${driverName}",
                        'FLUVADEC_HW_BACKEND=vaapi',
                        "GST_PLUGIN_PATH=${gstPluginPath}",
                    ]) {
                        def thArg = fluster.th  ? "-th ${fluster.th}" : ""
                        def tthArg = fluster.tth  ? "-tth ${fluster.tth}" : ""
                        def summaryOutPath = "${logDir}/summary.log"

                        sh(script: 'vainfo', label: 'Run vainfo')
                        sh(script: 'gst-inspect-1.0 fluvadec', label: 'Run gst-inspect-1.0')

                        sh(
                            script: (
                                "./fluster.py ${fluster.mainArgs} run -t 60 -ts ${fluster.ts} " +
                                "-d ${fluster.decoder} ${thArg} ${tthArg} -j1 -so ${summaryOutPath}"),
                            label: 'Run Fluster'
                        )

                        def expectedSummaryOutPath = "${env.WORKSPACE}/expected.out"
                        def expectedSummaryGitPath = 'flu-va-drivers/qa-vdpau/Fluendo-H.264-HW-Gst1.0.out'
                        def flusterResultsBranch = getRepoBranch(FLUSTER_RESULT_REPO,
                            env.BRANCH_NAME, params.FLUSTER_RESULTS_BRANCH ?: 'master')
                        sh(script: ("git archive --format=tar --remote=${FLUSTER_RESULT_REPO} " + 
                                    "${flusterResultsBranch} ${expectedSummaryGitPath} | " +
                                    "tar -xO | grep -i '|Test|' -A 999 > ${expectedSummaryOutPath}"),
                           label: 'Download Fluster expected results')

                        def diffParams = '-uB -I"|Test|" -I"|TOTAL TIME|" --strip-trailing-cr'
                        def res = sh(script: "diff $diffParams ${expectedSummaryOutPath} ${summaryOutPath}",
                           label: 'Compare Fluster results', returnStatus: true)
                        if (res == 3) {
                            error("Fluster correct tests below time threshold (${tth})")
                        } else if (res == 2) {
                            error("Fluster correct tests below threshold (${th})")
                        } else if (res != 0) {
                            error("Fluster error (exit status is ${res})")
                        }
                    }
                }
            }

            def logPackageDirInWS = "${logDirInWS}/logs/archives"
            def logPackageDir = "${env.WORKSPACE}/${logPackageDirInWS}"
            def tarballFileName = "${driverName}_logs.tar.gz"
            sh(script: "mkdir -p ${logPackageDir} && tar -czf ${logPackageDir}/${tarballFileName} ${logDir}",
                label: 'Compress logs')
            stage('Upload logs') {
                archiveArtifacts(artifacts: "${logPackageDirInWS}/${tarballFileName}", allowEmptyArchive: true, fingerprint: true)
                sh(script: "rm -rf ${logPackageDir}", label: 'Remove log directory.')
            }
        }
    }
}

node(DEFAULT_NODE) {
    checkoutCerbero()

    stage('Publish') {
        withCredentials(DEFAULT_CREDENTIALS) {
            def args = [
                RELEASE_VERSION,
                '--user', "$USERNAME",
                '--password', "$PASSWORD",
                '--no-prompt'
            ]
            if (!IS_RELEASE) {
                args += ['--dry-run']
            }
            args = args.join(' ')

            for (driver in DRIVERS) {
                def cmd = "publish-flu-va-drivers-${driver}"

                dir('fluendo-cerbero') {
                    sh (script: "./cerbero-uninstalled -t ${cmd} ${args}",
                        label: 'Publish')
                }
            }
        }
    }

    stage('Release') {
        withCredentials(DEFAULT_CREDENTIALS) {
            def cbc = 'projects/flu-va-drivers/flu-va-drivers.cbc'

            for (driver in DRIVERS) {
                unstash(driver)

                for (targetDistro in RELEASE_TARGET_DISTROS) {
                    def packagesDir = "${env.WORKSPACE}/packages/${driver}/${targetDistro.distro}"
                    def packageFiles
                    dir(packagesDir) {
                        def globPattern = "*.${targetDistro.extension}"
                        packageFiles = findFiles(glob: globPattern)
                    }

                    for (packageFile in packageFiles) {
                        def cmd = "upload-flu-va-drivers-${driver}"
                        def args = [
                            '--user', "$USERNAME",
                            '--password', "$PASSWORD",
                            '--version', RELEASE_VERSION,
                            '--target-platform', 'linux',
                            '--target-distro', targetDistro.distro,
                            '--target-arch', 'x86_64',
                            '--release_file', "${packagesDir}/${packageFile}",
                        ]
                        if (!IS_RELEASE) {
                            args += ['--dry-run']
                        }
                        args = args.join(' ')

                        dir('fluendo-cerbero') {
                            sh (script: "./cerbero-uninstalled -t ${cmd} ${args}",
                                label: 'Release')
                        }
                    }
                }
            }
        }
    }
}

def checkoutCerbero() {
    def cerberoRepo = 'git@github.com:fluendo/fluendo-cerbero.git'
    def branchOrTag = getRepoBranch(cerberoRepo, env.BRANCH_NAME ?: '1.0', '1.0')

    echo "Using fluendo-cerbero branch (or tag) '${branchOrTag}'"
    sh "test -d fluendo-cerbero/.git || git clone --recurse-submodules -b 1.0 git@github.com:fluendo/fluendo-cerbero.git fluendo-cerbero"

    sh "cd fluendo-cerbero && git reset --hard && git fetch --all --tags -f"
    sh "cd fluendo-cerbero && git checkout ${branchOrTag} && (git reset --hard origin/${branchOrTag} || git reset --hard ${branchOrTag})"
    sh "cd fluendo-cerbero && git submodule update --init --recursive"
    sh "python3 -m pip install -r fluendo-cerbero/requirements.txt"
}


def getRepoBranch(repo, branchName, defaultBranch = '1.0', required=false) {
    if (branchName == 'master' || branchName == '1.0') {
        return defaultBranch
    }

    def res = sh(script: "git ls-remote --heads --tags ${repo} ${branchName} | wc -l", returnStdout: true).trim()
    if (res == '1') {
        return branchName
    } else if (required) {
        error("Branch or tag '${branchName}' doesn't exist in ${repo}")
    }

    return defaultBranch
}

def flusterCloneRepo(repoDir, flusterBranch = 'master') {
    sh "rm -rf ${repoDir}"
    sh(script: "git clone -v --recurse-submodules --depth=1 --shallow-submodules -b ${flusterBranch} ${FLUSTER_REPO} ${repoDir}",
       label: "Cloning fluster")
    sh "cd ${repoDir} && git log -1"
}

def flusterDownloadTS(fluster) {
    sh "test -d ${fluster.resourcesDir}/${fluster.ts} || (cd ${fluster.repoDir} && ./fluster.py ${fluster.mainArgs} download ${fluster.ts})"
}

def isRelease(tagName) {
    return tagName && tagName != 'master' && tagName ==~ RELEASE_TAG_PATTERN
}
